package generator

import (
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/frk/isvalid/internal/analysis"

	GO "github.com/frk/ast/golang"
)

var _ = log.Println

const (
	isvalidPkgPath = `github.com/frk/isvalid`

	filePreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/isvalid".`
)

type Config struct {
	// ...
}

type TargetInfo struct {
	ValidatorStruct *analysis.ValidatorStruct
	Info            *analysis.Info
}

func Write(f io.Writer, pkgName string, targets []*TargetInfo, conf Config) error {
	file := buildFile(pkgName, targets, conf)
	return GO.Write(file, f)
}

type file struct {
	GO.File
	// The target file's import declaration.
	imports *GO.ImportDecl
	// List of statements to be produced for the body of an init function.
	// If the slice is empty then the init function will not be generated.
	init []GO.StmtNode

	importIsvalid bool // file needs to import "github.com/frk/isvalid"
	importStrings bool // file needs to import "strings"
	importErrors  bool // file needs to import "errors"
	importFmt     bool // file needs to import "fmt"

}

type generator struct {
	// The generator configuration.
	conf Config
	// The analyzed validator type for which the code is being generated.
	vs *analysis.ValidatorStruct
	// Additional info associated with the validator type's analysis.
	info *analysis.Info
	// The target file to be build by the generator.
	file *file
	// The generated Validation method's receiver
	recv GO.Ident
}

func buildFile(pkgName string, targets []*TargetInfo, conf Config) GO.File {
	file := new(file)
	for _, t := range targets {
		g := new(generator)
		g.conf = conf
		g.info = t.Info
		g.vs = t.ValidatorStruct
		g.file = file

		buildCode(g, t.ValidatorStruct)
	}

	if len(file.init) > 0 {
		init := GO.FuncDecl{}
		init.Name.Name = "init"
		init.Body.List = file.init
		file.Decls = append([]GO.TopLevelDeclNode{init}, file.Decls...)
	}

	var imports = new(GO.ImportDecl)
	if file.importErrors {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "errors"})
	}
	if file.importFmt {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "fmt"})
	}
	if file.importStrings {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "strings"})
	}
	if file.importIsvalid {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: isvalidPkgPath})
	}
	groupImports(imports)

	file.PkgName = pkgName
	file.Preamble = GO.LineComment{filePreamble}
	file.Imports = []GO.ImportDeclNode{imports}

	return file.File
}

func buildCode(g *generator, vs *analysis.ValidatorStruct) {
	g.recv = GO.Ident{"v"}
	body := []GO.StmtNode{}
	for _, f := range vs.Fields {
		buildFieldCode(g, f, g.recv, &body)
	}
	body = append(body, newFinalReturnStmt(g, g.recv))

	method := GO.MethodDecl{}
	method.Recv.Name = g.recv
	method.Recv.Type = GO.Ident{vs.TypeName}
	method.Name.Name = "Validate"
	method.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	method.Body.List = body

	g.file.Decls = append(g.file.Decls, method)
}

func buildFieldCode(g *generator, field *analysis.StructField, root GO.ExprNode, body *[]GO.StmtNode) {
	rules := field.RulesCopy()
	subfields := field.SubFields()
	if len(rules) == 0 && len(subfields) == 0 { // nothing to do?
		return
	}

	fieldExpr := GO.ExprNode(GO.SelectorExpr{X: root, Sel: GO.Ident{field.Name}})

	// special case: no if-stmt necessary for this field, but possibly subfields
	if field.Type.Kind != analysis.TypeKindPtr && len(rules) == 0 && len(subfields) > 0 {
		root := GO.Ident{"f"}
		block := []GO.StmtNode{}
		for _, f := range subfields {
			buildFieldCode(g, f, root, &block)
		}

		if len(block) > 0 {
			assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: root, Rhs: fieldExpr}
			block = append([]GO.StmtNode{assign}, block...)

			*body = append(*body, GO.BlockStmt{block})
		}
		return
	}

	var required, notnil *analysis.Rule
	for i := 0; i < len(rules); i++ {
		if r := rules[i]; r.Name == "required" || r.Name == "notnil" {
			if r.Name == "required" {
				required = r
			} else if r.Name == "notnil" {
				notnil = r
			}

			// delete (from https://github.com/golang/go/wiki/SliceTricks)
			copy(rules[i:], rules[i+1:])
			rules[len(rules)-1] = nil
			rules = rules[:len(rules)-1]

		}
	}

	mainIf := GO.IfStmt{}
	nilId := GO.Ident{"nil"}
	fieldType := field.Type
	ruleElseIf := (fieldType.Kind != analysis.TypeKindPtr && len(subfields) == 0)

	if fieldType.Kind == analysis.TypeKindPtr {
		// logical op, and equality op
		lop, eop := GO.BinaryLAnd, GO.BinaryNeq
		if required != nil || notnil != nil {
			lop, eop = GO.BinaryLOr, GO.BinaryEql
		}

		mainIf.Cond = GO.BinaryExpr{Op: eop, X: fieldExpr, Y: nilId}
		fieldExpr = GO.PointerIndirectionExpr{fieldExpr}
		fieldType = *fieldType.Elem

		// handle multiple pointers
		for fieldType.Kind == analysis.TypeKindPtr {
			mainIf.Cond = GO.BinaryExpr{Op: lop, X: mainIf.Cond, Y: GO.BinaryExpr{Op: eop, X: fieldExpr, Y: nilId}}
			fieldExpr = GO.PointerIndirectionExpr{fieldExpr}
			fieldType = *fieldType.Elem
		}
	}

	if required != nil || notnil != nil {
		var ruleExpr GO.ExprNode
		var retStmt GO.StmtNode
		var context string
		if required != nil {
			ruleExpr = makeExprForRequired(g, fieldType.Kind, fieldExpr)
			retStmt = newReturnStmtForError(g, required, field, fieldExpr)
			context = required.Context
		} else if notnil != nil {
			ruleExpr = makeExprForNotnil(g, fieldType.Kind, fieldExpr)
			retStmt = newReturnStmtForError(g, notnil, field, fieldExpr)
			context = notnil.Context
		}

		// context
		if len(context) > 0 {
			opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
			bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(context)}
			ruleExpr = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ruleExpr, Y: bin}
		}

		if ruleExpr != nil {
			if mainIf.Cond != nil {
				mainIf.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: mainIf.Cond, Y: ruleExpr}
			} else {
				mainIf.Cond = ruleExpr
			}
		}

		if retStmt != nil {
			mainIf.Body.Add(retStmt)
		}
	}

	if len(rules) > 0 || len(subfields) > 0 {
		block := []GO.StmtNode{}
		if mainIf.Cond != nil && !ruleElseIf {
			fieldVar := GO.Ident{"f"}
			assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: fieldVar, Rhs: fieldExpr}
			block = append(block, assign)

			fieldExpr = fieldVar
		}

		if len(rules) > 0 {
			ruleIf, elseIf := GO.IfStmt{}, (*GO.IfStmt)(nil)
			for _, r := range rules {
				rIf := ruleIfStmtMap[r.Name](g, r, field, fieldExpr)

				// context
				if len(r.Context) > 0 {
					opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
					bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(r.Context)}
					rIf.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: rIf.Cond, Y: bin}
				}

				if elseIf != nil {
					elseIf.Else = &rIf
					elseIf = &rIf
				} else if ruleIf.Cond != nil {
					ruleIf.Else = &rIf
					elseIf = &rIf
				} else {
					ruleIf = rIf
				}
			}

			if mainIf.Cond != nil && !ruleElseIf {
				block = append(block, ruleIf)
			} else if mainIf.Cond != nil {
				mainIf.Else = ruleIf
			} else {
				mainIf = ruleIf
			}
		}

		// loop over subfields
		if len(subfields) > 0 {
			for _, f := range subfields {
				buildFieldCode(g, f, fieldExpr, &block)
			}
		}

		if (required != nil || notnil != nil) && !ruleElseIf {
			mainIf.Else = GO.BlockStmt{block}
		} else {
			mainIf.Body.Add(block...)
		}
	}

	*body = append(*body, mainIf)
}

func makeExprForRequired(g *generator, kind analysis.TypeKind, fieldExpr GO.ExprNode) GO.ExprNode {
	switch kind {
	case analysis.TypeKindString, analysis.TypeKindMap, analysis.TypeKindSlice:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: GO.CallLenExpr{fieldExpr}, Y: GO.IntLit(0)}
	case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.IntLit(0)}
	case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.IntLit(0)}
	case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.ValueLit("0.0")}
	case analysis.TypeKindBool:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.ValueLit("false")}
	case analysis.TypeKindInterface:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.Ident{"nil"}}
	}
	return nil
}

func makeExprForNotnil(g *generator, kind analysis.TypeKind, fieldExpr GO.ExprNode) GO.ExprNode {
	switch kind {
	case analysis.TypeKindInterface, analysis.TypeKindMap, analysis.TypeKindSlice:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.Ident{"nil"}}
	}
	return nil
}

var ruleIfStmtMap = map[string]func(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) GO.IfStmt{
	"email":    ifStmtMaker("Email"),
	"url":      ifStmtMaker("URL"),
	"uri":      ifStmtMaker("URI"),
	"pan":      ifStmtMaker("PAN"),
	"cvv":      ifStmtMaker("CVV"),
	"ssn":      ifStmtMaker("SSN"),
	"ein":      ifStmtMaker("EIN"),
	"numeric":  ifStmtMaker("Numeric"),
	"hex":      ifStmtMaker("Hex"),
	"hexcolor": ifStmtMaker("HexColor"),
	"alphanum": ifStmtMaker("Alphanum"),
	"cidr":     ifStmtMaker("CIDR"),
	"phone":    makeIfStmtForPhone,
	"zip":      makeIfStmtForZip,
	"uuid":     makeIfStmtForUUID,
	"ip":       makeIfStmtForIP,
	"mac":      makeIfStmtForMAC,
	"iso":      makeIfStmtForISO,
	"rfc":      makeIfStmtForRFC,
	"re":       makeIfStmtForRegexp,
	"prefix":   makeIfStmtForPrefix,
	"suffix":   makeIfStmtForSuffix,
	"contains": makeIfStmtForContains,
	"eq":       makeIfStmtForEquals,
	"ne":       makeIfStmtForNotEquals,

	"gt":  makeIfStmtForGreaterThan,
	"lt":  makeIfStmtForLessThan,
	"gte": makeIfStmtForGreaterThanOrEqual,
	"lte": makeIfStmtForLessThanOrEqual,
	"min": makeIfStmtForMin,
	"max": makeIfStmtForMax,
	"rng": makeIfStmtForRange,
	"len": makeIfStmtForLength,
}

func ifStmtMaker(funcName string) (maker func(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt)) {
	return func(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
		g.file.importIsvalid = true
		fn := GO.QualifiedIdent{"isvalid", funcName}
		call := GO.CallExpr{Fun: fn, Args: GO.ArgsList{List: fieldExpr}}
		retStmt := newReturnStmtForError(g, r, field, fieldExpr)

		ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
		ifs.Body.Add(retStmt)
		return ifs
	}
}

func makeIfStmtForPhone(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "Phone"}
	call := GO.CallExpr{Fun: fn}
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	args := GO.ExprList{fieldExpr}
	for _, a := range r.Args {
		if a.Type == analysis.ArgTypeReference {
		} else {
			args = append(args, GO.StringLit(a.Value))
		}
	}
	call.Args.List = args

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForZip(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "Zip"}
	call := GO.CallExpr{Fun: fn}
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	args := GO.ExprList{fieldExpr}
	for _, a := range r.Args {
		args = append(args, GO.StringLit(a.Value))
	}
	call.Args.List = args

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForUUID(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "UUID"}
	call := GO.CallExpr{Fun: fn}
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	args := GO.ExprList{fieldExpr}
	for _, a := range r.Args {
		// if analysis did its job correctly a.Value will be either a
		// single digit integer or a "v<DIGIT>" string, in the latter
		// case remove the "v" so we can pass the argument as int.
		v := a.Value
		if len(v) > 1 {
			v = v[1:]
		}
		args = append(args, GO.ValueLit(v))
	}
	call.Args.List = args

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForIP(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "IP"}
	call := GO.CallExpr{Fun: fn}
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	args := GO.ExprList{fieldExpr}
	for _, a := range r.Args {
		// if analysis did its job correctly a.Value will be either a
		// single digit integer or a "v<DIGIT>" string, in the latter
		// case remove the "v" so we can pass the argument as int.
		v := a.Value
		if len(v) > 1 {
			v = v[1:]
		}
		args = append(args, GO.ValueLit(v))
	}
	call.Args.List = args

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForMAC(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "MAC"}
	call := GO.CallExpr{Fun: fn}
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	args := GO.ExprList{fieldExpr}
	for _, a := range r.Args {
		// if analysis did its job correctly a.Value will be either a
		// single digit integer or a "v<DIGIT>" string, in the latter
		// case remove the "v" so we can pass the argument as int.
		v := a.Value
		if len(v) > 1 {
			v = v[1:]
		}
		args = append(args, GO.ValueLit(v))
	}
	call.Args.List = args

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForISO(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "ISO"}
	call := GO.CallExpr{Fun: fn}

	// if analysis did its job correctly r.Args will be of len 1
	// and the argument will represent an integer.
	arg := r.Args[0].Value
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)
	call.Args.List = GO.ExprList{fieldExpr, GO.ValueLit(arg)}

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForRFC(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "RFC"}
	call := GO.CallExpr{Fun: fn}

	// if analysis did its job correctly r.Args will be of len 1
	// and the argument will represent an integer.
	arg := r.Args[0].Value
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)
	call.Args.List = GO.ExprList{fieldExpr, GO.ValueLit(arg)}

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForRegexp(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importIsvalid = true
	fn := GO.QualifiedIdent{"isvalid", "Match"}
	call := GO.CallExpr{Fun: fn}

	// if analysis did its job correctly r.Args will be of len 1
	// and the argument will represent a regular expression.
	arg := r.Args[0].Value
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)
	call.Args.List = GO.ExprList{fieldExpr, GO.RawStringLit(arg)}

	// add a registry call for the init function
	regrx := GO.CallExpr{Fun: GO.QualifiedIdent{"isvalid", "RegisterRegexp"}}
	regrx.Args.List = GO.RawStringLit(arg)
	g.file.init = append(g.file.init, GO.ExprStmt{regrx})

	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForPrefix(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importStrings = true

	for _, a := range r.Args {
		call := GO.CallExpr{Fun: GO.QualifiedIdent{"strings", "HasPrefix"}}
		call.Args.List = GO.ExprList{fieldExpr, GO.StringLit(a.Value)}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
		} else {
			ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
		}
	}

	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForSuffix(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importStrings = true

	for _, a := range r.Args {
		call := GO.CallExpr{Fun: GO.QualifiedIdent{"strings", "HasSuffix"}}
		call.Args.List = GO.ExprList{fieldExpr, GO.StringLit(a.Value)}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
		} else {
			ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
		}
	}

	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForContains(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	g.file.importStrings = true

	for _, a := range r.Args {
		call := GO.CallExpr{Fun: GO.QualifiedIdent{"strings", "Contains"}}
		call.Args.List = GO.ExprList{fieldExpr, GO.StringLit(a.Value)}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
		} else {
			ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
		}
	}

	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForEquals(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	typ := field.Type
	for typ.Kind == analysis.TypeKindPtr {
		typ = *typ.Elem
	}

	for _, a := range r.Args {
		val := a.Value

		var y GO.ExprNode
		if typ.Kind == analysis.TypeKindString {
			y = GO.StringLit(val)
		} else if a.Type == analysis.ArgTypeString {
			if typ.Kind.IsNumeric() && len(val) == 0 {
				y = GO.IntLit(0)
				val = "0"
			} else {
				y = GO.StringLit(val)
			}
		} else {
			y = GO.ValueLit(val)
		}

		cond := GO.BinaryExpr{Op: GO.BinaryNeq, X: fieldExpr, Y: y}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: cond}
		} else {
			ifs.Cond = cond
		}
	}

	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForNotEquals(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	typ := field.Type
	for typ.Kind == analysis.TypeKindPtr {
		typ = *typ.Elem
	}

	for _, a := range r.Args {
		val := a.Value

		var y GO.ExprNode
		if typ.Kind == analysis.TypeKindString {
			y = GO.StringLit(val)
		} else if a.Type == analysis.ArgTypeString {
			if typ.Kind.IsNumeric() && len(val) == 0 {
				y = GO.IntLit(0)
				val = "0"
			} else {
				y = GO.StringLit(val)
			}
		} else {
			y = GO.ValueLit(val)
		}

		cond := GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: y}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: ifs.Cond, Y: cond}
		} else {
			ifs.Cond = cond
		}
	}

	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	ifs.Body.Add(retStmt)
	return ifs
}

func makeIfStmtForGreaterThan(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLeq, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForLessThan(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGeq, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForGreaterThanOrEqual(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLss, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForLessThanOrEqual(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGtr, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForMin(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLss, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForMax(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	arg := r.Args[0]
	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGtr, X: fieldExpr, Y: GO.ValueLit(arg.Value)}
	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForRange(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	a1, a2 := r.Args[0], r.Args[1]

	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
		X: GO.BinaryExpr{Op: GO.BinaryLss, X: fieldExpr, Y: newExprForArg(g, a1)},
		Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: fieldExpr, Y: newExprForArg(g, a2)}}

	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func makeIfStmtForLength(g *generator, r *analysis.Rule, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	if len(r.Args) == 1 {
		a := r.Args[0]
		ifs.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, a)}
		ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	} else { // len(r.Args) == 2 is assumed
		a1, a2 := r.Args[0], r.Args[1]
		if len(a1.Value) > 0 && len(a2.Value) == 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, a1)}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		} else if len(a1.Value) == 0 && len(a2.Value) > 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, a2)}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		} else {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
				X: GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, a1)},
				Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, a2)}}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		}
	}
	return ifs
}

func newExprForArg(g *generator, a *analysis.RuleArg) (x GO.ExprNode) {
	if a.Type == analysis.ArgTypeReference {
		x = g.recv
		ref := g.info.ArgReferenceMap[a]
		for _, f := range ref.Selector {
			x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
		}
		return x
	}
	return GO.ValueLit(a.Value)
}

func newReturnStmtForError(g *generator, r *analysis.Rule, f *analysis.StructField, fieldExpr GO.ExprNode) GO.StmtNode {
	// Resolve the alternative form of the error message,
	// currently only "len" supports alternative forms.
	var altform int
	if r.Name == "len" && len(r.Args) == 2 {
		if len(r.Args[0].Value) > 0 && len(r.Args[1].Value) == 0 {
			altform = 1
		} else if len(r.Args[0].Value) == 0 && len(r.Args[1].Value) > 0 {
			altform = 2
		} else {
			altform = 3
		}
	}

	// Get the error config.
	conf := errorConfigMap[r.Name][altform]

	// Build code for custom handler, if one exists.
	if g.vs.ErrorHandler != nil {
		args := make(GO.ExprList, 3)
		args[0] = GO.StringLit(f.Key)
		args[1] = fieldExpr
		args[2] = GO.StringLit(r.Name)

		for _, a := range r.Args {
			switch a.Type {
			case analysis.ArgTypeReference:
				x := GO.ExprNode(g.recv)
				ref := g.info.ArgReferenceMap[a]
				for _, f := range ref.Selector {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				args = append(args, x)
			case analysis.ArgTypeString:
				args = append(args, GO.StringLit(a.Value))
			default:
				args = append(args, GO.ValueLit(a.Value))
			}
		}

		eh := GO.SelectorExpr{X: GO.QualifiedIdent{"v", g.vs.ErrorHandler.Name}, Sel: GO.Ident{"Error"}}
		call := GO.CallExpr{Fun: eh, Args: GO.ArgsList{List: args}}
		if g.vs.ErrorHandler.IsAggregator {
			return GO.ExprStmt{call}
		} else {
			return GO.ReturnStmt{Result: call}
		}
	}

	// If no custom handler exists, just return the default error message.
	return GO.ReturnStmt{newExprForError(g, f, r, conf)}

}

func newExprForError(g *generator, f *analysis.StructField, r *analysis.Rule, conf errorConfig) (errExpr GO.ExprNode) {
	text := f.Key + " " + conf.text // primary error text
	typ := f.Type.Base()

	var refs GO.ExprList
	if conf.omitArgs == false {
		var args []string
		for _, a := range r.Args {
			// if the field's type is numeric an empty string arg can be overwritten as 0.
			if len(a.Value) == 0 && a.Type == analysis.ArgTypeString && typ.Kind.IsNumeric() {
				a = &analysis.RuleArg{Type: analysis.ArgTypeUint, Value: "0"}
			}

			// skip if still empty
			if len(a.Value) == 0 {
				continue
			}

			if a.Type == analysis.ArgTypeReference {
				x := GO.ExprNode(g.recv)
				ref := g.info.ArgReferenceMap[a]
				for _, f := range ref.Selector {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				refs = append(refs, x)
				args = append(args, "%v")
			} else if a.Type == analysis.ArgTypeString {
				args = append(args, strconv.Quote(a.Value))
			} else {
				args = append(args, a.Value)
			}
		}

		if len(args) > 0 {
			text += ": " + strings.Join(args, conf.argSep)
		}
	}

	if len(conf.suffix) > 0 {
		text += " " + conf.suffix
	}

	errText := GO.ValueLit(strconv.Quote(text))
	if len(refs) > 0 {
		g.file.importFmt = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"fmt", "Errorf"},
			Args: GO.ArgsList{List: append(GO.ExprList{errText}, refs...)}}
	} else {
		g.file.importErrors = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"errors", "New"},
			Args: GO.ArgsList{List: errText}}
	}
	return errExpr
}

func newFinalReturnStmt(g *generator, root GO.ExprNode) (stmt GO.ReturnStmt) {
	if g.vs.ErrorHandler != nil && g.vs.ErrorHandler.IsAggregator {
		eh := GO.SelectorExpr{X: root, Sel: GO.Ident{g.vs.ErrorHandler.Name}}
		stmt.Result = GO.CallExpr{Fun: GO.SelectorExpr{X: eh, Sel: GO.Ident{"Out"}}}
	} else {
		stmt.Result = GO.Ident{"nil"}
	}
	return stmt
}

// groupImports groups the imports into 3 groups separated by a new line, the
// 1st group will contain imports from the standard library, the 3rd group will
// contain imports from github.com/frk/isvalid..., and the 2nd group will contain
// the rest of the imports.
func groupImports(imports *GO.ImportDecl) {
	var specs1, specs2, specs3 []GO.ImportSpec
	for _, s := range imports.Specs {
		if strings.HasPrefix(string(s.Path), isvalidPkgPath) {
			specs3 = append(specs3, s)
		} else if i := strings.IndexByte(string(s.Path), '.'); i >= 0 {
			specs2 = append(specs2, s)
		} else {
			specs1 = append(specs1, s)
		}
	}

	var specs []GO.ImportSpec
	if len(specs1) > 0 {
		specs = append(specs, specs1...)
	}
	if len(specs2) > 0 {
		specs2[0].Doc = GO.NL{}
		specs = append(specs, specs2...)
	}
	if len(specs3) > 0 {
		specs3[0].Doc = GO.NL{}
		specs = append(specs, specs3...)
	}
	imports.Specs = specs
}

// error message configuation
type errorConfig struct {
	// primary text of the error message
	text string
	// if set, append the suffix to the error message
	suffix string
	// if the validation rule takes multiple arguments, separate them with
	// argSep in the errro message
	argSep string
	// even if the validation rule takes an argument, do not display it
	// in the error message
	omitArgs bool
}

// A map of errorConfigs used for generating error messages. The first key is
// the rule's name and the second key maps the alternative forms of the error.
var errorConfigMap = map[string]map[int]errorConfig{
	"required": {0: {text: "is required"}},
	"notnil":   {0: {text: "cannot be nil"}},
	"email":    {0: {text: "must be a valid email"}},
	"url":      {0: {text: "must be a valid URL"}},
	"uri":      {0: {text: "must be a valid URI"}},
	"pan":      {0: {text: "must be a valid PAN"}},
	"cvv":      {0: {text: "must be a valid CVV"}},
	"ssn":      {0: {text: "must be a valid SSN"}},
	"ein":      {0: {text: "must be a valid EIN"}},
	"numeric":  {0: {text: "must contain only digits [0-9]"}},
	"hex":      {0: {text: "must be a valid hexadecimal string"}},
	"hexcolor": {0: {text: "must be a valid hex color code"}},
	"alphanum": {0: {text: "must be an alphanumeric string"}},
	"cidr":     {0: {text: "must be a valid CIDR"}},
	"phone":    {0: {text: "must be a valid phone number", omitArgs: true}},
	"zip":      {0: {text: "must be a valid zip code", omitArgs: true}},
	"uuid":     {0: {text: "must be a valid UUID", omitArgs: true}},
	"ip":       {0: {text: "must be a valid IP", omitArgs: true}},
	"mac":      {0: {text: "must be a valid MAC", omitArgs: true}},
	"iso":      {0: {text: "must be a valid ISO"}},
	"rfc":      {0: {text: "must be a valid RFC"}},
	"re":       {0: {text: "must match the regular expression"}},
	"prefix":   {0: {text: "must be prefixed with", argSep: " or "}},
	"suffix":   {0: {text: "must be suffixed with", argSep: " or "}},
	"contains": {0: {text: "must contain substring", argSep: " or "}},
	"eq":       {0: {text: "must be equal to", argSep: " or "}},
	"ne":       {0: {text: "must not be equal to", argSep: " or "}},
	"gt":       {0: {text: "must be greater than"}},
	"lt":       {0: {text: "must be less than"}},
	"gte":      {0: {text: "must be greater than or equal to"}},
	"lte":      {0: {text: "must be less than or equal to"}},
	"min":      {0: {text: "must be greater than or equal to"}},
	"max":      {0: {text: "must be less than or equal to"}},
	"rng":      {0: {text: "must be between", argSep: " and "}},
	"len": {
		0: {text: "must be of length"},
		1: {text: "must be of length at least"},
		2: {text: "must be of length at most"},
		3: {text: "must be of length between", argSep: " and ", suffix: "(inclusive)"},
	},
}
