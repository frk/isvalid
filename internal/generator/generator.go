package generator

import (
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/frk/isvalid/internal/analysis"

	GO "github.com/frk/ast/golang"
)

var _ = log.Println

const (
	filePreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/isvalid".`
	pkgisvalid   = `github.com/frk/isvalid`
)

// The file type holds info about the file for which the code is being generated.
type file struct {
	// The ast.
	GO.File
	// List of imports requried by the file.
	impset []*impspec
	// If set, it indicates that the file needs to import "errors".
	importErrors bool
	// If set, it indicates that the file needs to import "fmt".
	importFmt bool
	// List of statements to be produced for the body of an init function
	// at the top of the file. If the slice is empty then the init function
	// will not be generated.
	init []GO.StmtNode
}

// The impspec type holds info that is used to generate a GO.ImportSpec node.
type impspec struct {
	// The package path of the import spec.
	path string
	// The package name associated with the import spec.
	name string
	// If set, it indicates that the Name field should be set
	// in the generated GO.ImportSpec node.
	local bool
	// Number of package's with the same name. This value is used by those
	// packages to modify their name in order to not cause an import conflict.
	num int
}

// The generator type holds the state of the generator.
type generator struct {
	// The analyzed validator type for which the code is being generated.
	vs *analysis.ValidatorStruct
	// Additional info associated with the validator type's analysis.
	info *analysis.Info
	// The target file to be build by the generator.
	file *file
	// The generated Validation method's receiver
	recv GO.Ident

	beforeValidate GO.StmtNode
	afterValidate  GO.StmtNode
}

type TargetInfo struct {
	ValidatorStruct *analysis.ValidatorStruct
	Info            *analysis.Info
}

// Generate produces the code for the given targets and writes it to w.
func Generate(w io.Writer, pkgName string, targets []*TargetInfo) error {
	file := new(file)
	for _, t := range targets {
		g := new(generator)
		g.info = t.Info
		g.vs = t.ValidatorStruct
		g.file = file

		buildMethodValidate(g)
	}

	// add an "init()" func if needed
	if len(file.init) > 0 {
		init := GO.FuncDecl{}
		init.Name.Name = "init"
		init.Body.List = file.init
		file.Decls = append([]GO.TopLevelDeclNode{init}, file.Decls...)
	}

	// final touch
	file.PkgName = pkgName
	file.Preamble = GO.LineComment{filePreamble}
	file.Imports = []GO.ImportDeclNode{newImportDeclNode(file)}

	// let's go
	return GO.Write(file.File, w)
}

// Builds the "Validate() error" method for the target validator struct.
func buildMethodValidate(g *generator) {
	g.recv = GO.Ident{"v"}
	prepareHookCalls(g)

	prepareRuleArgFieldSelectors(g, g.vs.Fields)

	body := []GO.StmtNode{}
	if g.beforeValidate != nil {
		body = append(body, g.beforeValidate)
	}
	for _, f := range g.vs.Fields {
		buildFieldCode(g, f, g.recv, &body)
	}
	if g.afterValidate != nil {
		body = append(body, g.afterValidate)
	}

	body = append(body, newFinalReturnStmt(g, g.recv))

	method := GO.MethodDecl{}
	method.Recv.Name = g.recv
	method.Recv.Type = GO.Ident{g.vs.TypeName}
	method.Name.Name = "Validate"
	method.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	method.Body.List = body

	g.file.Decls = append(g.file.Decls, method)
}

func prepareHookCalls(g *generator) {
	if g.vs.BeforeValidate != nil {
		var ERR = GO.Ident{"err"}
		var NIL = GO.Ident{"nil"}

		name := g.vs.BeforeValidate.Name
		call := GO.CallExpr{Fun: GO.QualifiedIdent{g.recv.Name, name}}
		assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: ERR, Rhs: call}
		binary := GO.BinaryExpr{Op: GO.BinaryNeq, X: ERR, Y: NIL}
		ifbody := GO.BlockStmt{[]GO.StmtNode{GO.ReturnStmt{ERR}}}
		g.beforeValidate = GO.IfStmt{Init: assign, Cond: binary, Body: ifbody}
	}

	if g.vs.AfterValidate != nil {
		var ERR = GO.Ident{"err"}
		var NIL = GO.Ident{"nil"}

		name := g.vs.AfterValidate.Name
		call := GO.CallExpr{Fun: GO.QualifiedIdent{g.recv.Name, name}}
		assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: ERR, Rhs: call}
		binary := GO.BinaryExpr{Op: GO.BinaryNeq, X: ERR, Y: NIL}
		body := GO.BlockStmt{[]GO.StmtNode{GO.ReturnStmt{ERR}}}
		g.afterValidate = GO.IfStmt{Init: assign, Cond: binary, Body: body}
	}
}

// prepares expressions for ...
// TODO
// - arg.Value -> <selector-field-expression>
// - slice of "protective" expressions that check for nil pointers
//	- the pointer dereferencing & field selector combo will be set as the <selector-field-expression>
//	- if more than one pointer depth and/or one field depth, assign the base as the <selector-field-expression>
// NOTE - need to keep track if <selector-field-expression> can or cannot be nil
//	- if yes, then before it is used in the expression of a RULE, it needs to be checked against nil
func prepareRuleArgFieldSelectors(g *generator, fields []*analysis.StructField) {
	for _, f := range fields {
		for _, r := range f.Rules {
			for _, a := range r.Args {
				if a.Type == analysis.ArgTypeField {
					// a.Value == is the unique key
					// a.Selector
				}
			}
		}

		// If this fields is a struct, or a pointer(s) to a struct, descend.
		if t := f.Type.PtrBase(); t.Kind == analysis.TypeKindStruct {
			prepareRuleArgFieldSelectors(g, t.Fields)
		}
	}
}

func buildFieldCode(g *generator, field *analysis.StructField, root GO.ExprNode, body *[]GO.StmtNode) {
	rules := field.RulesCopy()
	subfields := field.SubFields()
	if len(rules) == 0 && len(subfields) == 0 { // nothing to do?
		return
	}

	fieldExpr := GO.ExprNode(GO.SelectorExpr{X: root, Sel: GO.Ident{field.Name}})

	// special case: no if-stmt necessary for this field, but possibly subfields
	if field.Type.Kind != analysis.TypeKindPtr && len(rules) == 0 && len(subfields) > 0 {
		root := GO.Ident{"f"}
		block := []GO.StmtNode{}
		for _, f := range subfields {
			buildFieldCode(g, f, root, &block)
		}

		if len(block) > 0 {
			assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: root, Rhs: fieldExpr}
			block = append([]GO.StmtNode{assign}, block...)

			*body = append(*body, GO.BlockStmt{block})
		}
		return
	}

	var required, notnil *analysis.RuleTag
	for i := 0; i < len(rules); i++ {
		if r := rules[i]; r.Name == "required" || r.Name == "notnil" {
			if r.Name == "required" {
				required = r
			} else if r.Name == "notnil" {
				notnil = r
			}

			// delete (from https://github.com/golang/go/wiki/SliceTricks)
			copy(rules[i:], rules[i+1:])
			rules[len(rules)-1] = nil
			rules = rules[:len(rules)-1]

		}
	}

	mainIf := GO.IfStmt{}
	nilId := GO.Ident{"nil"}
	fieldType := field.Type
	ruleElseIf := (fieldType.Kind != analysis.TypeKindPtr && len(subfields) == 0)

	if fieldType.Kind == analysis.TypeKindPtr {
		// logical op, and equality op
		lop, eop := GO.BinaryLAnd, GO.BinaryNeq
		if required != nil || notnil != nil {
			lop, eop = GO.BinaryLOr, GO.BinaryEql
		}

		mainIf.Cond = GO.BinaryExpr{Op: eop, X: fieldExpr, Y: nilId}
		fieldExpr = GO.PointerIndirectionExpr{fieldExpr}
		fieldType = *fieldType.Elem

		// handle multiple pointers
		for fieldType.Kind == analysis.TypeKindPtr {
			mainIf.Cond = GO.BinaryExpr{Op: lop, X: mainIf.Cond, Y: GO.BinaryExpr{Op: eop, X: fieldExpr, Y: nilId}}
			fieldExpr = GO.PointerIndirectionExpr{fieldExpr}
			fieldType = *fieldType.Elem
		}
	}

	if required != nil || notnil != nil {
		var ruleExpr GO.ExprNode
		var retStmt GO.StmtNode
		var context string
		if required != nil {
			ruleExpr = newExprForRequired(g, fieldType.Kind, fieldExpr)
			retStmt = newReturnStmtForError(g, required, field, fieldExpr)
			context = required.Context
		} else if notnil != nil {
			ruleExpr = newExprForNotnil(g, fieldType.Kind, fieldExpr)
			retStmt = newReturnStmtForError(g, notnil, field, fieldExpr)
			context = notnil.Context
		}

		// context
		if len(context) > 0 {
			opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
			bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(context)}
			ruleExpr = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ruleExpr, Y: bin}
		}

		if ruleExpr != nil {
			if mainIf.Cond != nil {
				mainIf.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: mainIf.Cond, Y: ruleExpr}
			} else {
				mainIf.Cond = ruleExpr
			}
		}

		if retStmt != nil {
			mainIf.Body.Add(retStmt)
		}
	}

	if len(rules) > 0 || len(subfields) > 0 {
		block := []GO.StmtNode{}
		if mainIf.Cond != nil && !ruleElseIf {
			fieldVar := GO.Ident{"f"}
			assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: fieldVar, Rhs: fieldExpr}
			block = append(block, assign)

			fieldExpr = fieldVar
		}

		if len(rules) > 0 {
			ruleIf, elseIf := GO.IfStmt{}, (*GO.IfStmt)(nil)
			for _, r := range rules {
				rIf := newIfStmt(g, r, field, fieldExpr)

				// context
				if len(r.Context) > 0 {
					opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
					bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(r.Context)}
					rIf.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: rIf.Cond, Y: bin}
				}

				if elseIf != nil {
					elseIf.Else = &rIf
					elseIf = &rIf
				} else if ruleIf.Cond != nil {
					ruleIf.Else = &rIf
					elseIf = &rIf
				} else {
					ruleIf = rIf
				}
			}

			if mainIf.Cond != nil && !ruleElseIf {
				block = append(block, ruleIf)
			} else if mainIf.Cond != nil {
				mainIf.Else = ruleIf
			} else {
				mainIf = ruleIf
			}
		}

		// loop over subfields
		if len(subfields) > 0 {
			for _, f := range subfields {
				buildFieldCode(g, f, fieldExpr, &block)
			}
		}

		if (required != nil || notnil != nil) && !ruleElseIf {
			mainIf.Else = GO.BlockStmt{block}
		} else {
			mainIf.Body.Add(block...)
		}
	}

	*body = append(*body, mainIf)
}

func newExprForRequired(g *generator, kind analysis.TypeKind, fieldExpr GO.ExprNode) GO.ExprNode {
	switch kind {
	case analysis.TypeKindString, analysis.TypeKindMap, analysis.TypeKindSlice:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: GO.CallLenExpr{fieldExpr}, Y: GO.IntLit(0)}
	case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.IntLit(0)}
	case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.IntLit(0)}
	case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.ValueLit("0.0")}
	case analysis.TypeKindBool:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.ValueLit("false")}
	case analysis.TypeKindInterface:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.Ident{"nil"}}
	}
	return nil
}

func newExprForNotnil(g *generator, kind analysis.TypeKind, fieldExpr GO.ExprNode) GO.ExprNode {
	switch kind {
	case analysis.TypeKindInterface, analysis.TypeKindMap, analysis.TypeKindSlice:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: fieldExpr, Y: GO.Ident{"nil"}}
	}
	return nil
}

func newIfStmt(g *generator, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	spec := g.info.RuleSpecMap[r.Name]

	switch s := spec.(type) {
	case analysis.RuleBasic:
		if r.Name == "len" {
			return newIfStmtForLength(g, r, field, fieldExpr)
		} else if r.Name == "rng" {
			return newIfStmtForRange(g, r, field, fieldExpr)
		}
		return newIfStmtForBasicRule(g, r, field, fieldExpr)
	case analysis.RuleFunc:
		if s.BoolConn > analysis.RuleFuncBoolNone {
			return newIfStmtForFuncChained(g, s, r, field, fieldExpr)
		}
		return newIfStmtForFunc(g, s, r, field, fieldExpr)
	}

	panic("shouldn't reach")
	return ifs
}

func newExprForArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	if a.Type == analysis.ArgTypeField {
		return newExprForFieldArg(g, t, a, rf)
	}
	return newExprForConstArg(g, t, a, rf)
}

func newExprForFieldArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	var selector = g.info.SelectorMap[a.Value]
	var last *analysis.StructField

	x = g.recv
	for _, f := range selector {
		x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
		last = f
	}

	if t.NeedsConversion(last.Type) {
		cx := GO.CallExpr{}
		cx.Fun = GO.Ident{last.Type.String()}
		cx.Args = GO.ArgsList{List: x}
		x = cx
	}
	return x
}

func newExprForConstArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	if t.IsEmptyInterface {
		if a.Type == analysis.ArgTypeString {
			if rf != nil && rf.UseRawStrings {
				return GO.RawStringLit(a.Value)
			}
			return GO.ValueLit(strconv.Quote(a.Value))
		}

		return GO.ValueLit(a.Value)
	}

	if t.Kind == analysis.TypeKindString {
		if rf != nil && rf.UseRawStrings {
			return GO.RawStringLit(a.Value)
		}
		return GO.ValueLit(strconv.Quote(a.Value))
	}

	switch a.Type {
	case analysis.ArgTypeUnknown:
		switch t.Kind {
		case analysis.TypeKindString:
			x = GO.StringLit("")
		case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
			x = GO.IntLit(0)
		case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
			x = GO.IntLit(0)
		case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
			x = GO.ValueLit("0.0")
		case analysis.TypeKindBool:
			x = GO.ValueLit("false")
		case analysis.TypeKindPtr, analysis.TypeKindInterface, analysis.TypeKindMap, analysis.TypeKindSlice:
			x = GO.Ident{"nil"}
		}
		return x

	case analysis.ArgTypeBool:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeInt:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeFloat:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeString:
		if rf != nil && rf.UseRawStrings {
			x = GO.RawStringLit(a.Value)
		} else {
			x = GO.ValueLit(strconv.Quote(a.Value))
		}
		// TODO
		return x

	case analysis.ArgTypeField:
		x = g.recv
		for _, f := range g.info.SelectorMap[a.Value] {
			x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
		}
		return x
	}

	panic("shouldn't reach")
	return nil
}

func newIfStmtForFunc(g *generator, rf analysis.RuleFunc, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	imp := addImport(g, rf.PkgPath)
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	fn := GO.QualifiedIdent{imp.name, rf.FuncName}
	call := GO.CallExpr{Fun: fn, Args: GO.ArgsList{List: fieldExpr}}
	args := GO.ExprList{fieldExpr}

	argtypes := rf.TypesForArgs(r.Args)
	for i, a := range r.Args {
		args = append(args, newExprForArg(g, argtypes[i], a, &rf))

		if r.Name == "re" {
			// if this is the regexp rule, then add a registry
			// call for the init function and make sure to use
			// raw string literals.
			regrx := GO.CallExpr{Fun: GO.QualifiedIdent{imp.name, "RegisterRegexp"}}
			regrx.Args.List = GO.RawStringLit(a.Value)
			g.file.init = append(g.file.init, GO.ExprStmt{regrx})
		}
	}
	call.Args.List = args
	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func newIfStmtForFuncChained(g *generator, rf analysis.RuleFunc, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	imp := addImport(g, rf.PkgPath)
	retStmt := newReturnStmtForError(g, r, field, fieldExpr)

	argtypes := rf.TypesForArgs(r.Args)
	for i, a := range r.Args {
		call := GO.CallExpr{Fun: GO.QualifiedIdent{imp.name, rf.FuncName}}
		call.Args.List = GO.ExprList{fieldExpr, newExprForArg(g, argtypes[i], a, &rf)}

		switch rf.BoolConn {
		case analysis.RuleFuncBoolNot: // x || x || x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: ifs.Cond, Y: call}
			} else {
				ifs.Cond = call
			}
		case analysis.RuleFuncBoolAnd: // !x || !x || !x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
			} else {
				ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
			}
		case analysis.RuleFuncBoolOr: // !x && !x && !x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
			} else {
				ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
			}
		}
	}
	ifs.Body.Add(retStmt)
	return ifs
}

var basicRuleToBinaryOp = map[string]GO.BinaryOp{
	"eq":  GO.BinaryNeq,
	"ne":  GO.BinaryEql,
	"gt":  GO.BinaryLeq,
	"lt":  GO.BinaryGeq,
	"gte": GO.BinaryLss,
	"lte": GO.BinaryGtr,
	"min": GO.BinaryLss,
	"max": GO.BinaryGtr,
}

var basicRuleToLogicalOp = map[string]GO.BinaryOp{
	"eq": GO.BinaryLAnd,
	"ne": GO.BinaryLOr,
}

func newIfStmtForBasicRule(g *generator, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	typ := field.Type
	for typ.Kind == analysis.TypeKindPtr {
		typ = *typ.Elem
	}

	binop := basicRuleToBinaryOp[r.Name]
	logop := basicRuleToLogicalOp[r.Name]

	for _, a := range r.Args {
		cond := GO.BinaryExpr{Op: binop, X: fieldExpr, Y: newExprForArg(g, typ, a, nil)}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: logop, X: ifs.Cond, Y: cond}
		} else {
			ifs.Cond = cond
		}
	}

	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func newIfStmtForRange(g *generator, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	a1, a2 := r.Args[0], r.Args[1]

	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
		X: GO.BinaryExpr{Op: GO.BinaryLss, X: fieldExpr, Y: newExprForArg(g, field.Type.PtrBase(), a1, nil)},
		Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: fieldExpr, Y: newExprForArg(g, field.Type.PtrBase(), a2, nil)}}

	ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	return ifs
}

func newIfStmtForLength(g *generator, r *analysis.RuleTag, field *analysis.StructField, fieldExpr GO.ExprNode) (ifs GO.IfStmt) {
	typ := analysis.Type{Kind: analysis.TypeKindInt} // len(T) returns an int

	if len(r.Args) == 1 {
		a := r.Args[0]
		ifs.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, typ, a, nil)}
		ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
	} else { // len(r.Args) == 2 is assumed
		a1, a2 := r.Args[0], r.Args[1]
		if len(a1.Value) > 0 && len(a2.Value) == 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, typ, a1, nil)}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		} else if len(a1.Value) == 0 && len(a2.Value) > 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, typ, a2, nil)}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		} else {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
				X: GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, typ, a1, nil)},
				Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{fieldExpr}, Y: newExprForArg(g, typ, a2, nil)}}
			ifs.Body.Add(newReturnStmtForError(g, r, field, fieldExpr))
		}
	}
	return ifs
}

func newReturnStmtForError(g *generator, r *analysis.RuleTag, f *analysis.StructField, fieldExpr GO.ExprNode) GO.StmtNode {
	// Build code for custom handler, if one exists.
	if g.vs.ErrorHandler != nil {
		args := make(GO.ExprList, 3)
		args[0] = GO.StringLit(f.Key)
		args[1] = fieldExpr
		args[2] = GO.StringLit(r.Name)

		for _, a := range r.Args {
			switch a.Type {
			case analysis.ArgTypeField:
				x := GO.ExprNode(g.recv)
				for _, f := range g.info.SelectorMap[a.Value] {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				args = append(args, x)
			case analysis.ArgTypeString:
				args = append(args, GO.StringLit(a.Value))
			case analysis.ArgTypeUnknown:
				args = append(args, GO.StringLit(""))
			default:
				args = append(args, GO.ValueLit(a.Value))
			}
		}

		eh := GO.SelectorExpr{X: GO.QualifiedIdent{"v", g.vs.ErrorHandler.Name}, Sel: GO.Ident{"Error"}}
		call := GO.CallExpr{Fun: eh, Args: GO.ArgsList{List: args}}
		if g.vs.ErrorHandler.IsAggregator {
			return GO.ExprStmt{call}
		} else {
			return GO.ReturnStmt{Result: call}
		}
	}

	// If no custom handler exists, then return the default error message.
	return GO.ReturnStmt{newExprForError(g, f, r)}

}

func newExprForError(g *generator, f *analysis.StructField, r *analysis.RuleTag) (errExpr GO.ExprNode) {
	spec := g.info.RuleSpecMap[r.Name]
	if spec.IsCustom() {
		text := f.Key + " is not valid" // default error text for custom specs

		errText := GO.ValueLit(strconv.Quote(text))
		g.file.importErrors = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"errors", "New"},
			Args: GO.ArgsList{List: errText}}

		return errExpr
	}

	// Resolve the alternative form of the error message, currently only "len" needs this.
	var altform int
	if r.Name == "len" && len(r.Args) == 2 {
		if len(r.Args[0].Value) > 0 && len(r.Args[1].Value) == 0 {
			altform = 1
		} else if len(r.Args[0].Value) == 0 && len(r.Args[1].Value) > 0 {
			altform = 2
		} else {
			altform = 3
		}
	}

	// Get the error config.
	conf := errorConfigMap[r.Name][altform]
	text := f.Key + " " + conf.text // primary error text
	typ := f.Type.PtrBase()

	var refs GO.ExprList
	if !conf.omitArgs {
		var args []string
		for _, a := range r.Args {
			// if the field's type is numeric an unknown arg can be overwritten as 0.
			if a.Type == analysis.ArgTypeUnknown && typ.Kind.IsNumeric() {
				a = &analysis.RuleArg{Type: analysis.ArgTypeInt, Value: "0"}
			}

			// skip empty
			if len(a.Value) == 0 {
				continue
			}

			if a.Type == analysis.ArgTypeField {
				x := GO.ExprNode(g.recv)
				for _, f := range g.info.SelectorMap[a.Value] {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				refs = append(refs, x)
				args = append(args, "%v")
			} else if a.Type == analysis.ArgTypeString {
				args = append(args, strconv.Quote(a.Value))
			} else {
				args = append(args, a.Value)
			}
		}

		if len(args) > 0 {
			text += ": " + strings.Join(args, conf.argSep)
		}
	}

	if len(conf.suffix) > 0 {
		text += " " + conf.suffix
	}

	errText := GO.ValueLit(strconv.Quote(text))
	if len(refs) > 0 {
		g.file.importFmt = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"fmt", "Errorf"},
			Args: GO.ArgsList{List: append(GO.ExprList{errText}, refs...)}}
	} else {
		g.file.importErrors = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"errors", "New"},
			Args: GO.ArgsList{List: errText}}
	}
	return errExpr
}

func newFinalReturnStmt(g *generator, root GO.ExprNode) (stmt GO.ReturnStmt) {
	if g.vs.ErrorHandler != nil && g.vs.ErrorHandler.IsAggregator {
		eh := GO.SelectorExpr{X: root, Sel: GO.Ident{g.vs.ErrorHandler.Name}}
		stmt.Result = GO.CallExpr{Fun: GO.SelectorExpr{X: eh, Sel: GO.Ident{"Out"}}}
	} else {
		stmt.Result = GO.Ident{"nil"}
	}
	return stmt
}

func newImportDeclNode(f *file) GO.ImportDeclNode {
	var imports = new(GO.ImportDecl)

	if f.importErrors {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "errors"})
	}
	if f.importFmt {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "fmt"})
	}

	for _, imp := range f.impset {
		spec := GO.ImportSpec{Path: GO.StringLit(imp.path)}
		if imp.local {
			spec.Name.Name = imp.name
		}
		imports.Specs = append(imports.Specs, spec)
	}

	groupImports(imports)
	return imports
}

// groupImports groups the imports into 3 groups separated by a new line, the
// 1st group will contain imports from the standard library, the 3rd group will
// contain imports from github.com/frk/isvalid..., and the 2nd group will contain
// the rest of the imports.
func groupImports(imports *GO.ImportDecl) {
	var specs1, specs2, specs3 []GO.ImportSpec
	for _, s := range imports.Specs {
		if strings.HasPrefix(string(s.Path), pkgisvalid) {
			specs3 = append(specs3, s)
		} else if i := strings.IndexByte(string(s.Path), '.'); i >= 0 {
			specs2 = append(specs2, s)
		} else {
			specs1 = append(specs1, s)
		}
	}

	var specs []GO.ImportSpec
	if len(specs1) > 0 {
		specs = append(specs, specs1...)
	}
	if len(specs2) > 0 {
		specs2[0].Doc = GO.NL{}
		specs = append(specs, specs2...)
	}
	if len(specs3) > 0 {
		specs3[0].Doc = GO.NL{}
		specs = append(specs, specs3...)
	}
	imports.Specs = specs
}

// addImport
func addImport(g *generator, path string) *impspec {
	name := path
	if i := strings.LastIndexByte(name, '/'); i > -1 {
		name = name[i+1:]
	}

	var namesake *impspec
	for _, imp := range g.file.impset {
		// already added, exit
		if imp.path == path {
			return imp
		}

		// retain import that has the same name
		if imp.name == name {
			namesake = imp
		}
	}

	imp := &impspec{path: path, name: name}
	if namesake != nil {
		namesake.num += 1
		imp.name = name + strconv.Itoa(namesake.num)
		imp.local = true
	}

	g.file.impset = append(g.file.impset, imp)
	return imp
}

// error message configuation
type errorConfig struct {
	// primary text of the error message
	text string
	// if set, append the suffix to the error message
	suffix string
	// if the validation rule takes multiple arguments, separate them with
	// argSep in the errro message
	argSep string
	// even if the validation rule takes an argument, do not display it
	// in the error message
	omitArgs bool
}

// A map of errorConfigs used for generating error messages. The first key is
// the rule's name and the second key maps the alternative forms of the error.
var errorConfigMap = map[string]map[int]errorConfig{
	"required": {0: {text: "is required"}},
	"notnil":   {0: {text: "cannot be nil"}},
	"email":    {0: {text: "must be a valid email"}},
	"url":      {0: {text: "must be a valid URL"}},
	"uri":      {0: {text: "must be a valid URI"}},
	"pan":      {0: {text: "must be a valid PAN"}},
	"cvv":      {0: {text: "must be a valid CVV"}},
	"ssn":      {0: {text: "must be a valid SSN"}},
	"ein":      {0: {text: "must be a valid EIN"}},
	"numeric":  {0: {text: "must contain only digits [0-9]"}},
	"hex":      {0: {text: "must be a valid hexadecimal string"}},
	"hexcolor": {0: {text: "must be a valid hex color code"}},
	"alphanum": {0: {text: "must be an alphanumeric string"}},
	"cidr":     {0: {text: "must be a valid CIDR"}},
	"phone":    {0: {text: "must be a valid phone number", omitArgs: true}},
	"zip":      {0: {text: "must be a valid zip code", omitArgs: true}},
	"uuid":     {0: {text: "must be a valid UUID", omitArgs: true}},
	"ip":       {0: {text: "must be a valid IP", omitArgs: true}},
	"mac":      {0: {text: "must be a valid MAC", omitArgs: true}},
	"iso":      {0: {text: "must be a valid ISO"}},
	"rfc":      {0: {text: "must be a valid RFC"}},
	"re":       {0: {text: "must match the regular expression"}},
	"prefix":   {0: {text: "must be prefixed with", argSep: " or "}},
	"suffix":   {0: {text: "must be suffixed with", argSep: " or "}},
	"contains": {0: {text: "must contain substring", argSep: " or "}},
	"eq":       {0: {text: "must be equal to", argSep: " or "}},
	"ne":       {0: {text: "must not be equal to", argSep: " or "}},
	"gt":       {0: {text: "must be greater than"}},
	"lt":       {0: {text: "must be less than"}},
	"gte":      {0: {text: "must be greater than or equal to"}},
	"lte":      {0: {text: "must be less than or equal to"}},
	"min":      {0: {text: "must be greater than or equal to"}},
	"max":      {0: {text: "must be less than or equal to"}},
	"rng":      {0: {text: "must be between", argSep: " and "}},
	"len": {
		0: {text: "must be of length"},
		1: {text: "must be of length at least"},
		2: {text: "must be of length at most"},
		3: {text: "must be of length between", argSep: " and ", suffix: "(inclusive)"},
	},
}
