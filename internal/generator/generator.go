package generator

import (
	"io"
	"log"
	"strconv"
	"strings"

	"github.com/frk/isvalid/internal/analysis"

	GO "github.com/frk/ast/golang"
)

var _ = log.Println

const (
	filePreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/isvalid".`
	pkgisvalid   = `github.com/frk/isvalid`
)

// TargetAnalysis is used as the input to the generator, it holds
// the result of the target's analysis.
type TargetAnalysis struct {
	// the target struct
	ValidatorStruct *analysis.ValidatorStruct
	// additional info produced by the analysis
	Info *analysis.Info
}

// Generate produces the code for the given targets and writes it to w.
func Generate(w io.Writer, pkgName string, targets []*TargetAnalysis) error {
	file := new(file)
	for _, t := range targets {
		g := new(generator)
		g.info = t.Info
		g.vs = t.ValidatorStruct
		g.file = file

		buildMethodValidate(g)
	}

	// add an "init()" func if needed
	if len(file.init) > 0 {
		init := GO.FuncDecl{}
		init.Name.Name = "init"
		init.Body.List = file.init
		file.Decls = append([]GO.TopLevelDeclNode{init}, file.Decls...)
	}

	// final touch
	file.PkgName = pkgName
	file.Preamble = GO.LineComment{filePreamble}
	file.Imports = []GO.ImportDeclNode{newImportDeclNode(file)}

	// let's go
	return GO.Write(file.File, w)
}

// The file type holds info about the file for which the code is being generated.
type file struct {
	// The ast.
	GO.File
	// List of imports requried by the file.
	impset []*impspec
	// If set, it indicates that the file needs to import "errors".
	importErrors bool
	// If set, it indicates that the file needs to import "fmt".
	importFmt bool
	// List of statements to be produced for the body of an init function
	// at the top of the file. If the slice is empty then the init function
	// will not be generated.
	init []GO.StmtNode
}

// The impspec type holds info that is used to generate a GO.ImportSpec node.
type impspec struct {
	// The package path of the import spec.
	path string
	// The package name associated with the import spec.
	name string
	// If set, it indicates that the Name field should be set
	// in the generated GO.ImportSpec node.
	local bool
	// Number of package's with the same name. This value is used by those
	// packages to modify their name in order to not cause an import conflict.
	num int
}

// The generator type holds the state of the generator.
type generator struct {
	// The analyzed validator type for which the code is being generated.
	vs *analysis.ValidatorStruct
	// Additional info associated with the validator type's analysis.
	info *analysis.Info
	// The target file to be build by the generator.
	file *file
	// The generated Validation method's receiver
	recv GO.Ident

	fragments      []*fragment
	beforeValidate GO.StmtNode
	afterValidate  GO.StmtNode
}

// set of common nodes
var (
	ERR   = GO.Ident{"err"}
	NIL   = GO.Ident{"nil"}
	ERROR = GO.Ident{"error"}
)

// Builds the "Validate() error" method for the target validator struct.
func buildMethodValidate(g *generator) {
	g.recv = GO.Ident{"v"}
	prepareHookCalls(g)
	prepareFragments(g)

	body := []GO.StmtNode{}
	if g.beforeValidate != nil {
		body = append(body, g.beforeValidate)
	}

	buildFragments(g, &body)

	if g.afterValidate != nil {
		body = append(body, g.afterValidate)
	}

	body = append(body, newFinalReturnStmt(g, g.recv))

	method := GO.MethodDecl{}
	method.Recv.Name = g.recv
	method.Recv.Type = GO.Ident{g.vs.TypeName}
	method.Name.Name = "Validate"
	method.Type.Results = GO.ParamList{{Type: ERROR}}
	method.Body.List = body

	g.file.Decls = append(g.file.Decls, method)
}

func prepareHookCalls(g *generator) {
	if g.vs.BeforeValidate != nil {
		name := g.vs.BeforeValidate.Name
		call := GO.CallExpr{Fun: GO.QualifiedIdent{g.recv.Name, name}}
		assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: ERR, Rhs: call}
		binary := GO.BinaryExpr{Op: GO.BinaryNeq, X: ERR, Y: NIL}
		ifbody := GO.BlockStmt{[]GO.StmtNode{GO.ReturnStmt{ERR}}}
		g.beforeValidate = GO.IfStmt{Init: assign, Cond: binary, Body: ifbody}
	}

	if g.vs.AfterValidate != nil {
		name := g.vs.AfterValidate.Name
		call := GO.CallExpr{Fun: GO.QualifiedIdent{g.recv.Name, name}}
		assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: ERR, Rhs: call}
		binary := GO.BinaryExpr{Op: GO.BinaryNeq, X: ERR, Y: NIL}
		body := GO.BlockStmt{[]GO.StmtNode{GO.ReturnStmt{ERR}}}
		g.afterValidate = GO.IfStmt{Init: assign, Cond: binary, Body: body}
	}
}

type fragment struct {
	// The field for which the code is being prepared.
	f *analysis.StructField
	// The current value's type.
	typ analysis.Type
	// Set if the field's rule set contains "required", otherwise nil.
	required *analysis.Rule
	// Set if the field's rule set contains "notnil", otherwise nil.
	notnil *analysis.Rule
	// Holds the rest of the rules that should be applied directly to the current value.
	rules []*analysis.Rule
	// Set if the field's type is a map.
	key *fragment
	// Set if the field's type is a map, slice, or an array.
	elem *fragment
	// Populated if field's type is a struct.
	fields []*fragment

	// The current value's expression.
	x GO.ExprNode
	// nil guard
	ng GO.ExprNode
	// sub-block
	sb []GO.StmtNode
	// required rule
	ifrq *GO.IfStmt
	// notnil rule
	ifnn *GO.IfStmt
	// base rules
	ifbase []GO.IfStmt
	// key-elem rules
	ifkeyelem []GO.IfStmt
}

func prepareFragments(g *generator) {
	for _, f := range g.vs.Fields {
		if !f.ContainsRules() {
			continue
		}

		expr := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{f.Name}}
		frag := &fragment{f: f, typ: f.Type, x: expr}

		prepareFragment(g, frag, f.RuleTag)
		g.fragments = append(g.fragments, frag)
	}
}

func prepareFragment(g *generator, frag *fragment, rtag *analysis.RuleTag) {
	// first split rules:
	for _, r := range rtag.Rules {
		if r.Name == "required" {
			frag.required = r
		} else if r.Name == "notnil" {
			frag.notnil = r
		} else {
			frag.rules = append(frag.rules, r)
		}
	}

	prepareFragmentNilGuard(g, frag)
	prepareFieldRequired(g, frag)
	prepareFieldNotnil(g, frag)
	prepareFieldSubBlock(g, frag)
	prepareFieldBaseRules(g, frag)

	switch frag.typ.Kind {
	case analysis.TypeKindSlice, analysis.TypeKindArray:
		if rtag.Elem != nil {
			expr := GO.Ident{"e"}
			elem := &fragment{f: frag.f, typ: *frag.typ.Elem, x: expr}
			prepareFragment(g, elem, rtag.Elem)
			frag.elem = elem
		}
	case analysis.TypeKindMap:
		if rtag.Key != nil {
			expr := GO.Ident{"k"}
			key := &fragment{f: frag.f, typ: *frag.typ.Key, x: expr}
			prepareFragment(g, key, rtag.Key)
			frag.key = key
		}
		if rtag.Elem != nil {
			expr := GO.Ident{"e"}
			elem := &fragment{f: frag.f, typ: *frag.typ.Elem, x: expr}
			prepareFragment(g, elem, rtag.Elem)
			frag.elem = elem
		}
	case analysis.TypeKindStruct:
		for _, f := range frag.typ.Fields {
			if !f.ContainsRules() {
				continue
			}

			expr := GO.SelectorExpr{X: frag.x, Sel: GO.Ident{f.Name}}
			next := &fragment{f: f, typ: f.Type, x: expr}

			prepareFragment(g, next, f.RuleTag)
			frag.fields = append(frag.fields, next)

		}
	}
}

func prepareFragmentNilGuard(g *generator, frag *fragment) {
	if frag.typ.Kind != analysis.TypeKindPtr {
		return // nothing to do
	}

	// logical op, and equality op
	lop, eop := GO.BinaryLAnd, GO.BinaryNeq
	if frag.required != nil || frag.notnil != nil {
		lop, eop = GO.BinaryLOr, GO.BinaryEql
	}

	cond := GO.BinaryExpr{Op: eop, X: frag.x, Y: NIL}
	frag.x = GO.PointerIndirectionExpr{frag.x}
	frag.typ = *frag.typ.Elem

	// handle multiple pointers
	for frag.typ.Kind == analysis.TypeKindPtr {
		binx := GO.BinaryExpr{Op: eop, X: frag.x, Y: NIL}

		cond = GO.BinaryExpr{Op: lop, X: cond, Y: binx}
		frag.x = GO.PointerIndirectionExpr{frag.x}
		frag.typ = *frag.typ.Elem
	}

	frag.ng = cond
}

func prepareFieldRequired(g *generator, frag *fragment) {
	if frag.required == nil {
		return // nothing to do
	}

	cond := newExprForRequired(g, frag)
	if cond != nil && frag.ng != nil {
		cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: frag.ng, Y: cond}
	} else if frag.ng != nil {
		cond = frag.ng
	}

	if len(frag.required.Context) > 0 {
		opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
		bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(frag.required.Context)}
		cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: cond, Y: bin}
	}

	frag.ifrq = &GO.IfStmt{Cond: cond}
	frag.ifrq.Body.Add(newReturnStmtForError(g, frag, frag.required))
}

func prepareFieldNotnil(g *generator, frag *fragment) {
	if frag.notnil == nil {
		return // nothing to do
	}

	cond := newExprForNotnil(g, frag)
	if cond != nil && frag.ng != nil {
		cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: frag.ng, Y: cond}
	} else if frag.ng != nil {
		cond = frag.ng
	}

	if len(frag.notnil.Context) > 0 {
		opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
		bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(frag.notnil.Context)}
		cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: cond, Y: bin}
	}

	frag.ifnn = &GO.IfStmt{Cond: cond}
	frag.ifnn.Body.Add(newReturnStmtForError(g, frag, frag.notnil))
}

func prepareFieldSubBlock(g *generator, frag *fragment) {
	// no nil-guard and the deepest nested field is less than 2 nodes away
	// TODO MaxFieldDepth is atm uninterrupted, i.e. it doesn't care
	// if there are pointers, slices, maps etc. between the fields's types.
	// This needs to be update to stop the depth count at those types.
	if frag.ng == nil && frag.f.MaxFieldDepth < 2 {
		return // nothing to do
	}

	// no subfields and there's a "notnil" or "required" rule then we do not
	// need a sub-block, instead we want to chain the "notnil"/"required" IfStmt
	// with the IfStmt produced from ifbase.
	if len(frag.typ.Fields) == 0 && (frag.ifnn != nil || frag.ifrq != nil) {
		return // nothing to do
	}

	// no subfields and there's at most 1 rule, no sub-block
	if len(frag.typ.Fields) == 0 && len(frag.rules) < 2 {
		return // nothing to do
	}

	v := GO.Ident{"f"}
	a := GO.AssignStmt{Token: GO.AssignDefine, Lhs: v, Rhs: frag.x}

	frag.x = v
	frag.sb = append(frag.sb, a)
}

func prepareFieldBaseRules(g *generator, frag *fragment) {
	for _, r := range frag.rules {
		ifs := newIfStmt(g, frag, r)
		if len(r.Context) > 0 {
			opt := GO.SelectorExpr{X: g.recv, Sel: GO.Ident{g.vs.ContextOption.Name}}
			bin := GO.BinaryExpr{Op: GO.BinaryEql, X: opt, Y: GO.StringLit(r.Context)}
			ifs.Cond = GO.ParenExpr{GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: bin}}
		}

		frag.ifbase = append(frag.ifbase, ifs)
	}
}

func buildFragments(g *generator, body *[]GO.StmtNode) {
	for _, f := range g.fragments {
		if s := buildFragmentStmtNode(g, f); s != nil {
			*body = append(*body, s)
		}
	}
}

func buildFragmentStmtNode(g *generator, frag *fragment) GO.StmtNode {
	// block for subfields
	var stmtlist GO.StmtList
	for _, f := range frag.fields {
		if s := buildFragmentStmtNode(g, f); s != nil {
			stmtlist = append(stmtlist, s)
		}
	}
	if len(stmtlist) > 0 {
		return buildFieldSubBlock(g, frag, stmtlist)
	}

	// ifstmt for base rules
	ifs := buildFieldIfStmt(g, frag)
	if ifs.Cond != nil {
		return buildFieldSubBlock(g, frag, ifs)
	}

	if frag.key != nil || frag.elem != nil {
		log.Println("ey!", frag.x)
		node := buildFragmentForStmt(g, frag)
		if node.Clause != nil {
			if frag.ng != nil {
				return GO.IfStmt{Cond: frag.ng, Body: GO.BlockStmt{[]GO.StmtNode{node}}}
			}
			// if ng: build ng
			return buildFieldSubBlock(g, frag, node)
		}

		// TODO needs to be combined with ifstmt from above ...
		//      - say slice must be "len:1:5" and the each elem must be "email"
	}
	return nil
}

func buildFieldSubBlock(g *generator, fc *fragment, stmt GO.StmtNode) GO.StmtNode {
	if fc.sb == nil {
		return stmt
	}

	block := GO.BlockStmt{append(fc.sb, stmt)}
	if fc.ifrq != nil {
		ifs := *fc.ifrq
		ifs.Else = block
		return ifs
	} else if fc.ifnn != nil {
		ifs := *fc.ifnn
		ifs.Else = block
		return ifs
	} else if fc.ng != nil {
		return GO.IfStmt{Cond: fc.ng, Body: block}
	}
	return block
}

func buildFieldIfStmt(g *generator, fc *fragment) GO.IfStmt {
	var root GO.IfStmt

	// merge "required" or "notnil" IfStmt with the ifbase slice
	var iflist []GO.IfStmt
	if fc.ifrq != nil {
		iflist = []GO.IfStmt{*fc.ifrq}
	} else if fc.ifnn != nil {
		iflist = []GO.IfStmt{*fc.ifnn}
	}
	iflist = append(iflist, fc.ifbase...)

	// chain the if-statements
	for i := len(iflist) - 1; i >= 0; i-- {
		ifs := iflist[i]
		if root.Cond == nil {
			root = ifs
		} else {
			ifs.Else = root
			root = ifs
		}
	}

	// if "nilguard" present but no "required" and no "notnil" then if we have
	// only a single rule we can merge its conditional with that of the "nilguard",
	// note that this works only with single rules, multiple rules would end up
	// in else-ifs without the nilguard and could cause panic.
	if (fc.ng != nil && fc.ifrq == nil && fc.ifnn == nil) && len(fc.ifbase) == 1 {
		root.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: fc.ng, Y: root.Cond}
	}

	return root
}

// frag is the field containing the slice/array/map
// frag.key will hold fragment for a map key
// frag.elem will hold fragment for a slice/array/map elem
func buildFragmentForStmt(g *generator, frag *fragment) (fs GO.ForStmt) {
	rc := GO.ForRangeClause{X: frag.x, Define: true}
	switch frag.typ.Kind {
	case analysis.TypeKindSlice, analysis.TypeKindArray:
		rc.Key = GO.Ident{"_"}
		rc.Value = GO.Ident{"e"}
	case analysis.TypeKindMap:
		rc.Key = GO.Ident{"k"}
		rc.Value = GO.Ident{"e"}
	default:
		panic("shouldn't reach")
	}
	fs.Clause = rc

	if frag.typ.Kind == analysis.TypeKindMap {
		if sn := buildFragmentStmtNode(g, frag.key); sn != nil {
			fs.Body.List = append(fs.Body.List, sn)
		}
	}
	if sn := buildFragmentStmtNode(g, frag.elem); sn != nil {
		fs.Body.List = append(fs.Body.List, sn)
	}
	return fs
}

func newExprForRequired(g *generator, frag *fragment) GO.ExprNode {
	switch frag.typ.Kind {
	case analysis.TypeKindString, analysis.TypeKindMap, analysis.TypeKindSlice:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: GO.CallLenExpr{frag.x}, Y: GO.IntLit(0)}
	case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: GO.IntLit(0)}
	case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: GO.IntLit(0)}
	case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: GO.ValueLit("0.0")}
	case analysis.TypeKindBool:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: GO.ValueLit("false")}
	case analysis.TypeKindPtr, analysis.TypeKindInterface:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: NIL}
	}
	return nil
}

func newExprForNotnil(g *generator, frag *fragment) GO.ExprNode {
	switch frag.typ.Kind {
	case analysis.TypeKindPtr, analysis.TypeKindSlice, analysis.TypeKindMap, analysis.TypeKindInterface:
		return GO.BinaryExpr{Op: GO.BinaryEql, X: frag.x, Y: NIL}
	}
	return nil
}

func newIfStmt(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	spec := g.info.RuleSpecMap[r.Name]
	switch s := spec.(type) {
	case analysis.RuleIsValid:
		return newIfStmtForIsValid(g, frag, r)
	case analysis.RuleEnum:
		return newIfStmtForEnum(g, frag, r)
	case analysis.RuleBasic:
		if r.Name == "len" {
			return newIfStmtForLength(g, frag, r)
		} else if r.Name == "rng" {
			return newIfStmtForRange(g, frag, r)
		}
		return newIfStmtForBasic(g, frag, r)
	case analysis.RuleFunc:
		if s.BoolConn > analysis.RuleFuncBoolNone {
			return newIfStmtForFuncChained(g, frag, r, s)
		}
		return newIfStmtForFunc(g, frag, r, s)
	}

	panic("shouldn't reach")
	return ifs
}

func newExprForArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	if a.Type == analysis.ArgTypeField {
		return newExprForFieldArg(g, t, a, rf)
	}
	return newExprForConstArg(g, t, a, rf)
}

func newExprForFieldArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	var selector = g.info.SelectorMap[a.Value]
	var last *analysis.StructField

	x = g.recv
	for _, f := range selector {
		x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
		last = f
	}

	if t.NeedsConversion(last.Type) {
		cx := GO.CallExpr{}
		cx.Fun = GO.Ident{last.Type.String()}
		cx.Args = GO.ArgsList{List: x}
		x = cx
	}
	return x
}

func newExprForConstArg(g *generator, t analysis.Type, a *analysis.RuleArg, rf *analysis.RuleFunc) (x GO.ExprNode) {
	if t.IsEmptyInterface {
		if a.Type == analysis.ArgTypeString {
			if rf != nil && rf.UseRawStrings {
				return GO.RawStringLit(a.Value)
			}
			return GO.ValueLit(strconv.Quote(a.Value))
		}

		return GO.ValueLit(a.Value)
	}

	if t.Kind == analysis.TypeKindString {
		if rf != nil && rf.UseRawStrings {
			return GO.RawStringLit(a.Value)
		}
		return GO.ValueLit(strconv.Quote(a.Value))
	}

	switch a.Type {
	case analysis.ArgTypeUnknown:
		switch t.Kind {
		case analysis.TypeKindString:
			x = GO.StringLit("")
		case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
			x = GO.IntLit(0)
		case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
			x = GO.IntLit(0)
		case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
			x = GO.ValueLit("0.0")
		case analysis.TypeKindBool:
			x = GO.ValueLit("false")
		case analysis.TypeKindPtr, analysis.TypeKindInterface, analysis.TypeKindMap, analysis.TypeKindSlice:
			x = NIL
		}
		return x

	case analysis.ArgTypeBool:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeInt:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeFloat:
		x = GO.ValueLit(a.Value)
		// TODO
		return x

	case analysis.ArgTypeString:
		if rf != nil && rf.UseRawStrings {
			x = GO.RawStringLit(a.Value)
		} else {
			x = GO.ValueLit(strconv.Quote(a.Value))
		}
		// TODO
		return x

	case analysis.ArgTypeField:
		x = g.recv
		for _, f := range g.info.SelectorMap[a.Value] {
			x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
		}
		return x
	}

	panic("shouldn't reach")
	return nil
}

func newIfStmtForIsValid(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	x := frag.x
	if frag.f.Type.Kind == analysis.TypeKindPtr {
		x = GO.ParenExpr{x}
	}
	sel := GO.SelectorExpr{X: x, Sel: GO.Ident{"IsValid"}}
	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: GO.CallExpr{Fun: sel}}
	ifs.Body.Add(newReturnStmtForError(g, frag, r))
	return ifs
}

func newIfStmtForEnum(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	typ := frag.f.Type.PtrBase()
	ident := typ.PkgPath + "." + typ.Name
	enums := g.info.EnumMap[ident]

	for _, e := range enums {
		id := GO.ExprNode(GO.Ident{e.Name})
		if g.info.PkgPath != e.PkgPath {
			imp := addImport(g, e.PkgPath)
			id = GO.QualifiedIdent{imp.name, e.Name}
		}

		cond := GO.BinaryExpr{Op: GO.BinaryNeq, X: frag.x, Y: id}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: cond}
		} else {
			ifs.Cond = cond
		}
	}

	ifs.Body.Add(newReturnStmtForError(g, frag, r))
	return ifs
}

func newIfStmtForFunc(g *generator, frag *fragment, r *analysis.Rule, rf analysis.RuleFunc) (ifs GO.IfStmt) {
	imp := addImport(g, rf.PkgPath)
	retStmt := newReturnStmtForError(g, frag, r)

	fn := GO.QualifiedIdent{imp.name, rf.FuncName}
	call := GO.CallExpr{Fun: fn, Args: GO.ArgsList{List: frag.x}}
	args := GO.ExprList{frag.x}

	argtypes := rf.TypesForArgs(r.Args)
	for i, a := range r.Args {
		args = append(args, newExprForArg(g, argtypes[i], a, &rf))

		if r.Name == "re" {
			// if this is the regexp rule, then add a registry
			// call for the init function and make sure to use
			// raw string literals.
			regrx := GO.CallExpr{Fun: GO.QualifiedIdent{imp.name, "RegisterRegexp"}}
			regrx.Args.List = GO.RawStringLit(a.Value)
			g.file.init = append(g.file.init, GO.ExprStmt{regrx})
		}
	}
	call.Args.List = args
	ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
	ifs.Body.Add(retStmt)
	return ifs
}

func newIfStmtForFuncChained(g *generator, frag *fragment, r *analysis.Rule, rf analysis.RuleFunc) (ifs GO.IfStmt) {
	imp := addImport(g, rf.PkgPath)
	retStmt := newReturnStmtForError(g, frag, r)

	argtypes := rf.TypesForArgs(r.Args)
	for i, a := range r.Args {
		call := GO.CallExpr{Fun: GO.QualifiedIdent{imp.name, rf.FuncName}}
		call.Args.List = GO.ExprList{frag.x, newExprForArg(g, argtypes[i], a, &rf)}

		switch rf.BoolConn {
		case analysis.RuleFuncBoolNot: // x || x || x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: ifs.Cond, Y: call}
			} else {
				ifs.Cond = call
			}
		case analysis.RuleFuncBoolAnd: // !x || !x || !x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
			} else {
				ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
			}
		case analysis.RuleFuncBoolOr: // !x && !x && !x....
			if ifs.Cond != nil {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLAnd, X: ifs.Cond, Y: GO.UnaryExpr{Op: GO.UnaryNot, X: call}}
			} else {
				ifs.Cond = GO.UnaryExpr{Op: GO.UnaryNot, X: call}
			}
		}
	}
	ifs.Body.Add(retStmt)
	return ifs
}

func newIfStmtForBasic(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	typ := frag.f.Type
	for typ.Kind == analysis.TypeKindPtr {
		typ = *typ.Elem
	}

	binop := basicRuleToBinaryOp[r.Name]
	logop := basicRuleToLogicalOp[r.Name]

	for _, a := range r.Args {
		cond := GO.BinaryExpr{Op: binop, X: frag.x, Y: newExprForArg(g, typ, a, nil)}
		if ifs.Cond != nil {
			ifs.Cond = GO.BinaryExpr{Op: logop, X: ifs.Cond, Y: cond}
		} else {
			ifs.Cond = cond
		}
	}

	ifs.Body.Add(newReturnStmtForError(g, frag, r))
	return ifs
}

func newIfStmtForRange(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	a1, a2 := r.Args[0], r.Args[1]

	ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
		X: GO.BinaryExpr{Op: GO.BinaryLss, X: frag.x, Y: newExprForArg(g, frag.f.Type.PtrBase(), a1, nil)},
		Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: frag.x, Y: newExprForArg(g, frag.f.Type.PtrBase(), a2, nil)}}
	ifs.Cond = GO.ParenExpr{ifs.Cond}
	ifs.Body.Add(newReturnStmtForError(g, frag, r))
	return ifs
}

func newIfStmtForLength(g *generator, frag *fragment, r *analysis.Rule) (ifs GO.IfStmt) {
	typ := analysis.Type{Kind: analysis.TypeKindInt} // len(T) returns an int

	if len(r.Args) == 1 {
		a := r.Args[0]
		ifs.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: GO.CallLenExpr{frag.x}, Y: newExprForArg(g, typ, a, nil)}
		ifs.Body.Add(newReturnStmtForError(g, frag, r))
	} else { // len(r.Args) == 2 is assumed
		a1, a2 := r.Args[0], r.Args[1]
		if len(a1.Value) > 0 && len(a2.Value) == 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{frag.x}, Y: newExprForArg(g, typ, a1, nil)}
			ifs.Body.Add(newReturnStmtForError(g, frag, r))
		} else if len(a1.Value) == 0 && len(a2.Value) > 0 {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{frag.x}, Y: newExprForArg(g, typ, a2, nil)}
			ifs.Body.Add(newReturnStmtForError(g, frag, r))
		} else {
			ifs.Cond = GO.BinaryExpr{Op: GO.BinaryLOr,
				X: GO.BinaryExpr{Op: GO.BinaryLss, X: GO.CallLenExpr{frag.x}, Y: newExprForArg(g, typ, a1, nil)},
				Y: GO.BinaryExpr{Op: GO.BinaryGtr, X: GO.CallLenExpr{frag.x}, Y: newExprForArg(g, typ, a2, nil)}}
			ifs.Cond = GO.ParenExpr{ifs.Cond}
			ifs.Body.Add(newReturnStmtForError(g, frag, r))
		}
	}
	return ifs
}

func newReturnStmtForError(g *generator, frag *fragment, r *analysis.Rule) GO.StmtNode {
	// Build code for custom handler, if one exists.
	if g.vs.ErrorHandler != nil {
		args := make(GO.ExprList, 3)
		args[0] = GO.StringLit(frag.f.Key)
		args[1] = frag.x
		args[2] = GO.StringLit(r.Name)

		for _, a := range r.Args {
			switch a.Type {
			case analysis.ArgTypeField:
				x := GO.ExprNode(g.recv)
				for _, f := range g.info.SelectorMap[a.Value] {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				args = append(args, x)
			case analysis.ArgTypeString:
				args = append(args, GO.StringLit(a.Value))
			case analysis.ArgTypeUnknown:
				args = append(args, GO.StringLit(""))
			default:
				args = append(args, GO.ValueLit(a.Value))
			}
		}

		eh := GO.SelectorExpr{X: GO.QualifiedIdent{"v", g.vs.ErrorHandler.Name}, Sel: GO.Ident{"Error"}}
		call := GO.CallExpr{Fun: eh, Args: GO.ArgsList{List: args}}
		if g.vs.ErrorHandler.IsAggregator {
			return GO.ExprStmt{call}
		} else {
			return GO.ReturnStmt{Result: call}
		}
	}

	// If no custom handler exists, then return the default error message.
	return GO.ReturnStmt{newExprForError(g, frag, r)}

}

func newExprForError(g *generator, frag *fragment, r *analysis.Rule) (errExpr GO.ExprNode) {
	spec := g.info.RuleSpecMap[r.Name]
	if spec.IsCustom() {
		text := frag.f.Key + " is not valid" // default error text for custom specs

		errText := GO.ValueLit(strconv.Quote(text))
		g.file.importErrors = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"errors", "New"},
			Args: GO.ArgsList{List: errText}}

		return errExpr
	}

	// Resolve the alternative form of the error message, currently only "len" needs this.
	var altform int
	if r.Name == "len" && len(r.Args) == 2 {
		if len(r.Args[0].Value) > 0 && len(r.Args[1].Value) == 0 {
			altform = 1
		} else if len(r.Args[0].Value) == 0 && len(r.Args[1].Value) > 0 {
			altform = 2
		} else {
			altform = 3
		}
	}

	// Get the error config.
	conf := errorConfigMap[r.Name][altform]
	text := frag.f.Key + " " + conf.text // primary error text
	typ := frag.f.Type.PtrBase()

	var refs GO.ExprList
	if !conf.omitArgs {
		var args []string
		for _, a := range r.Args {
			// if the field's type is numeric an unknown arg can be overwritten as 0.
			if a.Type == analysis.ArgTypeUnknown && typ.Kind.IsNumeric() {
				a = &analysis.RuleArg{Type: analysis.ArgTypeInt, Value: "0"}
			}

			// skip empty
			if len(a.Value) == 0 {
				continue
			}

			if a.Type == analysis.ArgTypeField {
				x := GO.ExprNode(g.recv)
				for _, f := range g.info.SelectorMap[a.Value] {
					x = GO.SelectorExpr{X: x, Sel: GO.Ident{f.Name}}
				}
				refs = append(refs, x)
				args = append(args, "%v")
			} else if a.Type == analysis.ArgTypeString {
				args = append(args, strconv.Quote(a.Value))
			} else {
				args = append(args, a.Value)
			}
		}

		if len(args) > 0 {
			text += ": " + strings.Join(args, conf.argSep)
		}
	}

	if len(conf.suffix) > 0 {
		text += " " + conf.suffix
	}

	errText := GO.ValueLit(strconv.Quote(text))
	if len(refs) > 0 {
		g.file.importFmt = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"fmt", "Errorf"},
			Args: GO.ArgsList{List: append(GO.ExprList{errText}, refs...)}}
	} else {
		g.file.importErrors = true
		errExpr = GO.CallExpr{Fun: GO.QualifiedIdent{"errors", "New"},
			Args: GO.ArgsList{List: errText}}
	}
	return errExpr
}

func newFinalReturnStmt(g *generator, root GO.ExprNode) (stmt GO.ReturnStmt) {
	if g.vs.ErrorHandler != nil && g.vs.ErrorHandler.IsAggregator {
		eh := GO.SelectorExpr{X: root, Sel: GO.Ident{g.vs.ErrorHandler.Name}}
		stmt.Result = GO.CallExpr{Fun: GO.SelectorExpr{X: eh, Sel: GO.Ident{"Out"}}}
	} else {
		stmt.Result = NIL
	}
	return stmt
}

func newImportDeclNode(f *file) GO.ImportDeclNode {
	imports := new(GO.ImportDecl)
	if f.importErrors {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "errors"})
	}
	if f.importFmt {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "fmt"})
	}

	for _, imp := range f.impset {
		spec := GO.ImportSpec{Path: GO.StringLit(imp.path)}
		if imp.local {
			spec.Name.Name = imp.name
		}
		imports.Specs = append(imports.Specs, spec)
	}
	groupImports(imports)
	return imports
}

// groupImports groups the imports into 3 groups separated by a new line, the
// 1st group will contain imports from the standard library, the 3rd group will
// contain imports from github.com/frk/isvalid..., and the 2nd group will contain
// the rest of the imports.
func groupImports(imports *GO.ImportDecl) {
	var specs1, specs2, specs3 []GO.ImportSpec
	for _, s := range imports.Specs {
		if strings.HasPrefix(string(s.Path), pkgisvalid) {
			specs3 = append(specs3, s)
		} else if i := strings.IndexByte(string(s.Path), '.'); i >= 0 {
			specs2 = append(specs2, s)
		} else {
			specs1 = append(specs1, s)
		}
	}

	var specs []GO.ImportSpec
	if len(specs1) > 0 {
		specs = append(specs, specs1...)
	}
	if len(specs2) > 0 {
		specs2[0].Doc = GO.NL{}
		specs = append(specs, specs2...)
	}
	if len(specs3) > 0 {
		specs3[0].Doc = GO.NL{}
		specs = append(specs, specs3...)
	}
	imports.Specs = specs
}

// addImport
func addImport(g *generator, path string) *impspec {
	name := path
	if i := strings.LastIndexByte(name, '/'); i > -1 {
		name = name[i+1:]
	}

	var namesake *impspec
	for _, imp := range g.file.impset {
		// already added, exit
		if imp.path == path {
			return imp
		}

		// retain import that has the same name
		if imp.name == name {
			namesake = imp
		}
	}

	imp := &impspec{path: path, name: name}
	if namesake != nil {
		namesake.num += 1
		imp.name = name + strconv.Itoa(namesake.num)
		imp.local = true
	}

	g.file.impset = append(g.file.impset, imp)
	return imp
}

var basicRuleToBinaryOp = map[string]GO.BinaryOp{
	"eq":  GO.BinaryNeq,
	"ne":  GO.BinaryEql,
	"gt":  GO.BinaryLeq,
	"lt":  GO.BinaryGeq,
	"gte": GO.BinaryLss,
	"lte": GO.BinaryGtr,
	"min": GO.BinaryLss,
	"max": GO.BinaryGtr,
}

var basicRuleToLogicalOp = map[string]GO.BinaryOp{
	"eq": GO.BinaryLAnd,
	"ne": GO.BinaryLOr,
}

// error message configuation
type errorConfig struct {
	// primary text of the error message
	text string
	// if set, append the suffix to the error message
	suffix string
	// if the validation rule takes multiple arguments, separate them with
	// argSep in the errro message
	argSep string
	// even if the validation rule takes an argument, do not display it
	// in the error message
	omitArgs bool
}

// A map of errorConfigs used for generating error messages. The first key is
// the rule's name and the second key maps the alternative forms of the error.
var errorConfigMap = map[string]map[int]errorConfig{
	"required": {0: {text: "is required"}},
	"notnil":   {0: {text: "cannot be nil"}},
	"email":    {0: {text: "must be a valid email"}},
	"url":      {0: {text: "must be a valid URL"}},
	"uri":      {0: {text: "must be a valid URI"}},
	"pan":      {0: {text: "must be a valid PAN"}},
	"cvv":      {0: {text: "must be a valid CVV"}},
	"ssn":      {0: {text: "must be a valid SSN"}},
	"ein":      {0: {text: "must be a valid EIN"}},
	"numeric":  {0: {text: "must contain only digits [0-9]"}},
	"hex":      {0: {text: "must be a valid hexadecimal string"}},
	"hexcolor": {0: {text: "must be a valid hex color code"}},
	"alphanum": {0: {text: "must be an alphanumeric string"}},
	"cidr":     {0: {text: "must be a valid CIDR"}},
	"phone":    {0: {text: "must be a valid phone number", omitArgs: true}},
	"zip":      {0: {text: "must be a valid zip code", omitArgs: true}},
	"uuid":     {0: {text: "must be a valid UUID", omitArgs: true}},
	"ip":       {0: {text: "must be a valid IP", omitArgs: true}},
	"mac":      {0: {text: "must be a valid MAC", omitArgs: true}},
	"iso":      {0: {text: "must be a valid ISO"}},
	"rfc":      {0: {text: "must be a valid RFC"}},
	"re":       {0: {text: "must match the regular expression"}},
	"prefix":   {0: {text: "must be prefixed with", argSep: " or "}},
	"suffix":   {0: {text: "must be suffixed with", argSep: " or "}},
	"contains": {0: {text: "must contain substring", argSep: " or "}},
	"eq":       {0: {text: "must be equal to", argSep: " or "}},
	"ne":       {0: {text: "must not be equal to", argSep: " or "}},
	"gt":       {0: {text: "must be greater than"}},
	"lt":       {0: {text: "must be less than"}},
	"gte":      {0: {text: "must be greater than or equal to"}},
	"lte":      {0: {text: "must be less than or equal to"}},
	"min":      {0: {text: "must be greater than or equal to"}},
	"max":      {0: {text: "must be less than or equal to"}},
	"rng":      {0: {text: "must be between", argSep: " and "}},
	"len": {
		0: {text: "must be of length"},
		1: {text: "must be of length at least"},
		2: {text: "must be of length at most"},
		3: {text: "must be of length between", argSep: " and ", suffix: "(inclusive)"},
	},
}
