package generator

import (
	"io"
	"strings"

	"github.com/frk/isvalid/internal/analysis"

	GO "github.com/frk/ast/golang"
)

const (
	isvalidPkgPath = `github.com/frk/isvalid`

	filePreamble = ` DO NOT EDIT. This file was generated by "github.com/frk/isvalid".`
)

type Config struct {
	// ...
}

type TargetInfo struct {
	ValidatorStruct *analysis.ValidatorStruct
	Info            *analysis.Info
}

func Write(f io.Writer, pkgName string, targets []*TargetInfo, conf Config) error {
	var (
		file          = new(GO.File)
		imports       = new(GO.ImportDecl)
		importIsvalid bool
	)
	for _, t := range targets {
		g := new(generator)
		g.conf = conf
		g.info = t.Info
		g.file = file
		g.imports = imports
		g.root = GO.Ident{"v"}

		buildCode(g, t.ValidatorStruct)
		if g.importIsvalid {
			importIsvalid = true
		}
	}

	imports.Specs = append(imports.Specs, GO.ImportSpec{Path: "errors"})

	if importIsvalid {
		imports.Specs = append(imports.Specs, GO.ImportSpec{Path: isvalidPkgPath})
	}
	sortImports(imports)

	file.PkgName = pkgName
	file.Preamble = GO.LineComment{filePreamble}
	file.Imports = []GO.ImportDeclNode{imports}
	return GO.Write(file, f)
}

type generator struct {
	// The generator configuration.
	conf    Config
	info    *analysis.Info
	field   *analysis.StructField
	parents []*analysis.StructField
	rule    *analysis.Rule

	// The target file to be build by the generator.
	file *GO.File
	// The associated file's import declaration.
	imports       *GO.ImportDecl
	importIsvalid bool

	body []GO.StmtNode
	root GO.Ident
}

func buildCode(g *generator, vs *analysis.ValidatorStruct) {
	for _, f := range vs.Fields {
		g.field = f
		g.parents = nil
		buildFieldCode(g, vs)
	}
	g.body = append(g.body, GO.ReturnStmt{GO.Ident{"nil"}})

	method := GO.MethodDecl{}
	method.Recv.Name = g.root
	method.Recv.Type = GO.Ident{vs.TypeName}
	method.Name.Name = "Validate"
	method.Type.Results = GO.ParamList{{Type: GO.Ident{"error"}}}
	method.Body.List = g.body

	g.file.Decls = append(g.file.Decls, method)
}

func buildFieldCode(g *generator, vs *analysis.ValidatorStruct) {
	if subfields := g.field.SubFields(); subfields != nil {
		// TODO how to best handle subfields with no rules, i.e. skip/ignore them?
		var (
			fieldSel = GO.ExprNode(GO.SelectorExpr{X: g.root, Sel: GO.Ident{g.field.Name}})
			nilVal   = GO.Ident{"nil"}
			errmesg  = g.field.Key + " is required"

			// retain the current values
			field   = g.field
			parents = g.parents
			body    = g.body
			root    = g.root

			// reset the previous values
			reset = func() {
				g.body = append(body, g.body...)
				g.root = root
				g.field = field
				g.parents = parents
			}
		)

		g.root = GO.Ident{"w"}
		g.body = []GO.StmtNode{}

		// figure out the pointer depth
		ptr, typ := 0, field.Type
		for typ.Kind == analysis.TypeKindPtr {
			ptr, typ = ptr+1, *typ.Elem
		}

		if ptr == 0 {
			// Builds a plain block inside which the subfileds will
			// be validated, for example:
			//
			//	{
			//		w := v.F
			//		// ...
			// 	}
			assign := GO.AssignStmt{Token: GO.AssignDefine, Lhs: g.root, Rhs: fieldSel}
			g.body = append(g.body, assign)

			done := reset // to avoid circular func calls
			reset = func() {
				g.body = []GO.StmtNode{GO.BlockStmt{g.body}}
				done()
			}
		} else if ptr == 1 {
			// Builds an if-statetment with a simple statement to initialize
			// a variable for the current field, inside the if's block the
			// subfileds will be validated, for example:
			//
			//	if w := v.F; w != nil {
			//		// ...
			// 	}
			// or:
			//	if w := v.F; w == nil {
			//		return errors.New("...")
			// 	} else {
			//		// ...
			//	}
			ifs := GO.IfStmt{}
			ifs.Init = GO.AssignStmt{Token: GO.AssignDefine, Lhs: g.root, Rhs: fieldSel}

			if field.HasRuleRequired() || field.HasRuleNotnil() {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryEql, X: g.root, Y: nilVal}
				ifs.Body.Add(buildReturnErrorStmt(g, vs, errmesg))

				done := reset // to avoid circular func calls
				reset = func() {
					ifs.Else = GO.BlockStmt{g.body}
					g.body = []GO.StmtNode{ifs}
					done()
				}
			} else {
				ifs.Cond = GO.BinaryExpr{Op: GO.BinaryNeq, X: g.root, Y: nilVal}

				done := reset // to avoid circular func calls
				reset = func() {
					ifs.Body.List = g.body
					g.body = []GO.StmtNode{ifs}
					done()
				}
			}
		} else if ptr > 1 {
			// Builds an if-statetment checking each pointer for nil
			// before validating the subfileds inside the if's block,
			// for example:
			//
			//	if v.F != nil && *v.F != nil && **v.F != nil && ***v.F != nil && ****v.F != nil {
			//		w := ****v.F
			// 		// ...
			// 	}
			// or:
			//	if v.F == nil || *v.F == nil || **v.F == nil || ***v.F == nil || ****v.F == nil {
			// 		return error.New("...")
			// 	} else {
			// 		w := ****v.F
			// 		// ...
			// 	}

			ifs := GO.IfStmt{}
			lop := GO.BinaryOp("") // logical op
			eop := GO.BinaryOp("") // equality op
			done := reset          // to avoid circular func calls

			if field.HasRuleRequired() || field.HasRuleNotnil() {
				lop = GO.BinaryLOr
				eop = GO.BinaryEql
				reset = func() {
					ifs.Else = GO.BlockStmt{g.body}
					g.body = []GO.StmtNode{ifs}
					done()
				}

				ifs.Body.Add(buildReturnErrorStmt(g, vs, errmesg))
			} else {
				lop = GO.BinaryLAnd
				eop = GO.BinaryNeq
				reset = func() {
					ifs.Body.List = g.body
					g.body = []GO.StmtNode{ifs}
					done()
				}
			}

			ifs.Cond = GO.BinaryExpr{Op: eop, X: fieldSel, Y: nilVal}
			for i := 1; i < ptr; i++ {
				fieldSel = GO.PointerIndirectionExpr{fieldSel}
				ifs.Cond = GO.BinaryExpr{Op: lop, X: ifs.Cond, Y: GO.BinaryExpr{Op: eop, X: fieldSel, Y: nilVal}}
			}
			g.body = append(g.body, GO.AssignStmt{Token: GO.AssignDefine, Lhs: g.root, Rhs: fieldSel})
		}

		parents2 := append(parents, field)
		for _, f := range subfields {
			g.field = f
			g.parents = parents2
			buildFieldCode(g, vs)
		}

		reset()
		return
	}

	for _, r := range g.field.Rules {
		g.rule = r
		buildRuleMap[r.Name](g, vs)
	}
}

var buildRuleMap = map[string]func(g *generator, vs *analysis.ValidatorStruct){
	"required": buildRuleRequired,
}

func buildRuleRequired(g *generator, vs *analysis.ValidatorStruct) {
	var (
		fieldSel = GO.ExprNode(GO.SelectorExpr{X: g.root, Sel: GO.Ident{g.field.Name}})
		nilVal   = GO.Ident{"nil"}
		errmesg  = g.field.Key + " is required"
		cond     GO.ExprNode
	)

	// pointer nil check & dereferencing
	typ := g.field.Type
	for typ.Kind == analysis.TypeKindPtr {
		typ = *typ.Elem

		expr := GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: nilVal}
		if cond != nil {
			cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: cond, Y: expr}
		} else {
			cond = expr
		}

		// update v.F to *v.F
		fieldSel = GO.PointerIndirectionExpr{fieldSel}
	}

	// the binary expression
	var expr GO.ExprNode

	switch typ.Kind {
	case analysis.TypeKindString, analysis.TypeKindMap, analysis.TypeKindSlice:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: GO.CallLenExpr{fieldSel}, Y: GO.IntLit(0)}
	case analysis.TypeKindInt, analysis.TypeKindInt8, analysis.TypeKindInt16, analysis.TypeKindInt32, analysis.TypeKindInt64:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: GO.IntLit(0)}
	case analysis.TypeKindUint, analysis.TypeKindUint8, analysis.TypeKindUint16, analysis.TypeKindUint32, analysis.TypeKindUint64:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: GO.IntLit(0)}
	case analysis.TypeKindFloat32, analysis.TypeKindFloat64:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: GO.ValueLit("0.0")}
	case analysis.TypeKindBool:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: GO.ValueLit("false")}
	case analysis.TypeKindInterface:
		expr = GO.BinaryExpr{Op: GO.BinaryEql, X: fieldSel, Y: nilVal}
	}

	if expr != nil {
		if cond != nil {
			cond = GO.BinaryExpr{Op: GO.BinaryLOr, X: cond, Y: expr}
		} else {
			cond = expr
		}
	}

	ifs := GO.IfStmt{}
	ifs.Cond = cond
	ifs.Body.Add(buildReturnErrorStmt(g, vs, errmesg))
	g.body = append(g.body, ifs)
}

func buildReturnErrorStmt(g *generator, vs *analysis.ValidatorStruct, errmesg string) (ret GO.ReturnStmt) {
	errnew := GO.QualifiedIdent{"errors", "New"}
	ret.Result = GO.CallExpr{Fun: errnew, Args: GO.ArgsList{List: GO.StringLit(errmesg)}}
	return ret
}

// addImport
func addImport(g *generator, path, name, local string) {
	// check that the package path hasn't yet been added to the imports
	for _, spec := range g.imports.Specs {
		if string(spec.Path) == path {
			return
		}
	}

	// if the local name is the same as the package name set it to empty
	if local == name {
		local = ""
	}

	spec := GO.ImportSpec{Path: GO.StringLit(path), Name: GO.Ident{local}}
	g.imports.Specs = append(g.imports.Specs, spec)
}

func sortImports(imports *GO.ImportDecl) {
	var specs1, specs2, specs3 []GO.ImportSpec
	for _, s := range imports.Specs {
		if strings.HasPrefix(string(s.Path), isvalidPkgPath) {
			specs3 = append(specs3, s)
		} else if i := strings.IndexByte(string(s.Path), '.'); i >= 0 {
			specs2 = append(specs2, s)
		} else {
			specs1 = append(specs1, s)
		}
	}

	var specs []GO.ImportSpec
	if len(specs1) > 0 {
		specs = append(specs, specs1...)
	}
	if len(specs2) > 0 {
		specs2[0].Doc = GO.NL{}
		specs = append(specs, specs2...)
	}
	if len(specs3) > 0 {
		specs3[0].Doc = GO.NL{}
		specs = append(specs, specs3...)
	}
	imports.Specs = specs
}
